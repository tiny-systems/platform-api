"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformPath = void 0;
const pathResponses_1 = require("../pathResponses");
const pathParameters_1 = require("./pathParameters");
const security_1 = require("./security");
const markdown_1 = require("../../lib/markdown");
const types_1 = require("../../types");
const externalDocs_1 = require("./externalDocs");
const schemes_1 = require("./schemes");
/**
 * https://swagger.io/specification/v2/#pathsObject
 * https://swagger.io/specification/v2/#pathItemObject
 * https://swagger.io/specification/v2/#operationObject
 */
function transformPath(path, data, _parameters) {
    let pathParameters = null;
    if (!path || !data) {
        return null;
    }
    const md = markdown_1.Markdown.md();
    // Make path as a header
    md.line(md.string(path).h3());
    // Check if parameter for path are in the place
    if ('parameters' in data) {
        pathParameters = data.parameters;
    }
    // Go further method by methods
    Object.keys(data).forEach((method) => {
        if (types_1.ALLOWED_METHODS.includes(method)) {
            md.line('');
            // Set method as a subheader
            md.line(md.string(method.toUpperCase()).h4());
            const pathInfo = data[method];
            // Deprecation
            if ('deprecated' in pathInfo && pathInfo.deprecated === true) {
                md.line(md.string('DEPRECATED').bold().italic());
            }
            // Schemes
            if ('schemes' in pathInfo && pathInfo.schemes.length > 0) {
                md.line((0, schemes_1.transformSchemes)(pathInfo.schemes));
            }
            // Set summary
            if ('summary' in pathInfo) {
                md.line(md.string('Summary:').h5())
                    .line()
                    .line(md.string(pathInfo.summary).escape())
                    .line();
            }
            // Set description
            if ('description' in pathInfo) {
                md.line(md.string('Description:').h5())
                    .line()
                    .line(md.string(pathInfo.description).escape())
                    .line();
            }
            // Set externalDocs
            if ('externalDocs' in pathInfo) {
                md.line(md.string('Documentation:').bold(), md.string(' '), (0, externalDocs_1.transformExternalDocs)(pathInfo.externalDocs));
            }
            // Build parameters
            if ('parameters' in pathInfo || pathParameters) {
                const builtParameters = md.string((0, pathParameters_1.transformParameters)(pathInfo.parameters, pathParameters));
                if (builtParameters.length) {
                    md.line(builtParameters).line();
                }
            }
            // Build responses
            if ('responses' in pathInfo) {
                const builtResponses = md.string((0, pathResponses_1.transformResponses)(pathInfo.responses));
                if (builtResponses.length) {
                    md.line(builtResponses).line();
                }
            }
            // Build security
            if ('security' in pathInfo) {
                md.line((0, security_1.transformSecurity)(pathInfo.security));
            }
        }
    });
    return md.export();
}
exports.transformPath = transformPath;
