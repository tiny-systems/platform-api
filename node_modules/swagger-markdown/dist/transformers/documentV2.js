"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformSwaggerV2 = void 0;
const info_1 = require("./v2/info");
const path_1 = require("./v2/path");
const securityDefinitions_1 = require("./v2/securityDefinitions");
const externalDocs_1 = require("./v2/externalDocs");
const definitions_1 = require("./definitions");
const Tags_1 = require("../models/Tags");
const markdown_1 = require("../lib/markdown");
const groupPathsByTags_1 = require("./v2/groupPathsByTags");
const tag_1 = require("./v2/tag");
const schemes_1 = require("./v2/schemes");
function transformSwaggerV2(inputDoc, options) {
    const md = markdown_1.Markdown.md();
    // Skip host, basePath, produces and consumes
    // those are used for the mock server and won't be rendered
    // Security and Responses are supposed to be dereferenced (?)
    // and shall not be present in the root namespace
    // Process info
    if (!options.skipInfo && 'info' in inputDoc) {
        md.line((0, info_1.transformInfo)(inputDoc.info));
    }
    // Collect tags
    const tagsCollection = new Tags_1.TagsCollection();
    if ('tags' in inputDoc) {
        inputDoc.tags.forEach((tag) => {
            tagsCollection.tag(tag);
        });
    }
    if ('externalDocs' in inputDoc) {
        md.line((0, externalDocs_1.transformExternalDocs)(inputDoc.externalDocs));
    }
    // Security definitions
    if ('securityDefinitions' in inputDoc) {
        md.line((0, securityDefinitions_1.transformSecurityDefinitions)(inputDoc.securityDefinitions));
        // } else if (inputDoc.components && inputDoc.components.securitySchemas) {
        //   document.push(transformSecurityDefinitions(inputDoc.components.securityDefinitions));
    }
    // Schemes
    if ('schemes' in inputDoc) {
        md.line((0, schemes_1.transformSchemes)(inputDoc.schemes));
    }
    // Collect parameters
    const parameters = 'parameters' in inputDoc ? inputDoc.parameters : {};
    // Process Paths
    if ('paths' in inputDoc) {
        // Group paths by tag name
        const tagged = (0, groupPathsByTags_1.groupPathsByTags)(inputDoc.paths);
        Object.keys(tagged).forEach((tagName) => {
            md.line(md.string().horizontalRule());
            if (tagsCollection.length) {
                // Display Tag
                const tagObject = tagsCollection.getTag(tagName) || '';
                md.line((0, tag_1.transformTag)(tagObject));
            }
            const pathsUnderTag = tagged[tagName];
            Object.keys(pathsUnderTag).forEach((path) => md.line((0, path_1.transformPath)(path, inputDoc.paths[path], parameters)));
        });
    }
    // Models (definitions)
    if ('definitions' in inputDoc) {
        md.line(md.string().horizontalRule());
        md.line((0, definitions_1.transformDefinition)(inputDoc.definitions));
        // } else if (inputDoc.components && inputDoc.components.schemas) {
        //   document.push(transformDefinition(inputDoc.components.schemas));
    }
    // Glue all pieces down
    return md.export();
}
exports.transformSwaggerV2 = transformSwaggerV2;
